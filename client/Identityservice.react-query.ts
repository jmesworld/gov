/**
 * This file was automatically generated by @cosmwasm/ts-codegen@0.24.0.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import {
  UseQueryOptions,
  useQuery,
  useMutation,
  UseMutationOptions,
} from '@tanstack/react-query';
import { ExecuteResult } from '@cosmjs/cosmwasm-stargate';
import { StdFee, Coin } from '@cosmjs/amino';
import {
  Addr,
  DaosResponse,
  ExecuteMsg,
  Duration,
  RegisterDaoMsg,
  Member,
  IdType,
  GetIdentityByNameResponse,
  Identity,
  GetIdentityByOwnerResponse,
  InstantiateMsg,
  QueryMsg,
  Ordering,
} from './Identityservice.types';
import {
  IdentityserviceQueryClient,
  IdentityserviceClient,
} from './Identityservice.client';
export const identityserviceQueryKeys = {
  contract: [
    {
      contract: 'identityservice',
    },
  ] as const,
  address: (contractAddress: string | undefined) =>
    [
      { ...identityserviceQueryKeys.contract[0], address: contractAddress },
    ] as const,
  getIdentityByOwner: (
    contractAddress: string | undefined,
    args?: Record<string, unknown>,
  ) =>
    [
      {
        ...identityserviceQueryKeys.address(contractAddress)[0],
        method: 'get_identity_by_owner',
        args,
      },
    ] as const,
  getIdentityByName: (
    contractAddress: string | undefined,
    args?: Record<string, unknown>,
  ) =>
    [
      {
        ...identityserviceQueryKeys.address(contractAddress)[0],
        method: 'get_identity_by_name',
        args,
      },
    ] as const,
  daos: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [
      {
        ...identityserviceQueryKeys.address(contractAddress)[0],
        method: 'daos',
        args,
      },
    ] as const,
};
export interface IdentityserviceReactQuery<TResponse, TData = TResponse> {
  client: IdentityserviceQueryClient | undefined;
  options?: Omit<
    UseQueryOptions<TResponse, Error, TData>,
    "'queryKey' | 'queryFn' | 'initialData'"
  > & {
    initialData?: undefined;
  };
}
export interface IdentityserviceDaosQuery<TData>
  extends IdentityserviceReactQuery<DaosResponse, TData> {
  args: {
    limit?: number;
    order?: Ordering;
    startAfter?: number;
  };
}
export function useIdentityserviceDaosQuery<TData = DaosResponse>({
  client,
  args,
  options,
}: IdentityserviceDaosQuery<TData>) {
  return useQuery<DaosResponse, Error, TData>(
    identityserviceQueryKeys.daos(client?.contractAddress, args),
    () =>
      client
        ? client.daos({
            limit: args.limit,
            order: args.order,
            startAfter: args.startAfter,
          })
        : Promise.reject(new Error('Invalid client')),
    {
      ...options,
      enabled:
        !!client && (options?.enabled != undefined ? options.enabled : true),
    },
  );
}
export interface IdentityserviceGetIdentityByNameQuery<TData>
  extends IdentityserviceReactQuery<GetIdentityByNameResponse, TData> {
  args: {
    name: string;
  };
}
export function useIdentityserviceGetIdentityByNameQuery<
  TData = GetIdentityByNameResponse,
>({ client, args, options }: IdentityserviceGetIdentityByNameQuery<TData>) {
  return useQuery<GetIdentityByNameResponse, Error, TData>(
    identityserviceQueryKeys.getIdentityByName(client?.contractAddress, args),
    () =>
      client
        ? client.getIdentityByName({
            name: args.name,
          })
        : Promise.reject(new Error('Invalid client')),
    {
      ...options,
      enabled:
        !!client && (options?.enabled != undefined ? options.enabled : true),
    },
  );
}
export interface IdentityserviceGetIdentityByOwnerQuery<TData>
  extends IdentityserviceReactQuery<GetIdentityByOwnerResponse, TData> {
  args: {
    owner: string;
  };
}
export function useIdentityserviceGetIdentityByOwnerQuery<
  TData = GetIdentityByOwnerResponse,
>({ client, args, options }: IdentityserviceGetIdentityByOwnerQuery<TData>) {
  return useQuery<GetIdentityByOwnerResponse, Error, TData>(
    identityserviceQueryKeys.getIdentityByOwner(client?.contractAddress, args),
    () =>
      client
        ? client.getIdentityByOwner({
            owner: args.owner,
          })
        : Promise.reject(new Error('Invalid client')),
    {
      ...options,
      enabled:
        !!client && (options?.enabled != undefined ? options.enabled : true),
    },
  );
}
export interface IdentityserviceRegisterDaoMutation {
  client: IdentityserviceClient;
  msg: {
    daoName: string;
    maxVotingPeriod: Duration;
    members: Member[];
    thresholdPercentage: number;
  };
  args?: {
    fee?: number | StdFee | 'auto';
    memo?: string;
    funds?: Coin[];
  };
}
export function useIdentityserviceRegisterDaoMutation(
  options?: Omit<
    UseMutationOptions<
      ExecuteResult,
      Error,
      IdentityserviceRegisterDaoMutation
    >,
    'mutationFn'
  >,
) {
  return useMutation<ExecuteResult, Error, IdentityserviceRegisterDaoMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.registerDao(msg, fee, memo, funds),
    options,
  );
}
export interface IdentityserviceRegisterUserMutation {
  client: IdentityserviceClient;
  msg: {
    name: string;
  };
  args?: {
    fee?: number | StdFee | 'auto';
    memo?: string;
    funds?: Coin[];
  };
}
export function useIdentityserviceRegisterUserMutation(
  options?: Omit<
    UseMutationOptions<
      ExecuteResult,
      Error,
      IdentityserviceRegisterUserMutation
    >,
    'mutationFn'
  >,
) {
  return useMutation<ExecuteResult, Error, IdentityserviceRegisterUserMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.registerUser(msg, fee, memo, funds),
    options,
  );
}
