/**
* This file was automatically generated by @jmes-cosmwasm/ts-codegen@0.14.2.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @jmes-cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery, useMutation, UseMutationOptions } from "@tanstack/react-query";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { Coin, Coins, WaitTxBroadcastResult } from "@terra-money/terra.js";
import { Uint128, Logo, EmbeddedLogo, Binary, InstantiateMsg, Cw20Coin, InstantiateMarketingInfo, MinterResponse, ExecuteMsg, Expiration, Timestamp, Uint64, QueryMsg, AllAccountsResponse, AllAllowancesResponse, AllowanceInfo, AllSpenderAllowancesResponse, SpenderAllowanceInfo, AllowanceResponse, BalanceResponse, DownloadLogoResponse, LogoInfo, Addr, MarketingInfoResponse, TokenInfoResponse } from "./BjmesToken.types";
import { BjmesTokenQueryClient, BjmesTokenClient } from "./BjmesToken.client";
export const bjmesTokenQueryKeys = {
  contract: ([{
    contract: "bjmesToken"
  }] as const),
  address: (contractAddress: string | undefined) => ([{ ...bjmesTokenQueryKeys.contract[0],
    address: contractAddress
  }] as const),
  balance: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...bjmesTokenQueryKeys.address(contractAddress)[0],
    method: "balance",
    args
  }] as const),
  balanceAt: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...bjmesTokenQueryKeys.address(contractAddress)[0],
    method: "balance_at",
    args
  }] as const),
  totalSupplyAt: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...bjmesTokenQueryKeys.address(contractAddress)[0],
    method: "total_supply_at",
    args
  }] as const),
  tokenInfo: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...bjmesTokenQueryKeys.address(contractAddress)[0],
    method: "token_info",
    args
  }] as const),
  minter: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...bjmesTokenQueryKeys.address(contractAddress)[0],
    method: "minter",
    args
  }] as const),
  allowance: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...bjmesTokenQueryKeys.address(contractAddress)[0],
    method: "allowance",
    args
  }] as const),
  allAllowances: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...bjmesTokenQueryKeys.address(contractAddress)[0],
    method: "all_allowances",
    args
  }] as const),
  allSpenderAllowances: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...bjmesTokenQueryKeys.address(contractAddress)[0],
    method: "all_spender_allowances",
    args
  }] as const),
  allAccounts: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...bjmesTokenQueryKeys.address(contractAddress)[0],
    method: "all_accounts",
    args
  }] as const),
  marketingInfo: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...bjmesTokenQueryKeys.address(contractAddress)[0],
    method: "marketing_info",
    args
  }] as const),
  downloadLogo: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...bjmesTokenQueryKeys.address(contractAddress)[0],
    method: "download_logo",
    args
  }] as const)
};
export interface BjmesTokenReactQuery<TResponse, TData = TResponse> {
  client: BjmesTokenQueryClient | undefined;
  options?: Omit<UseQueryOptions<TResponse, Error, TData>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export interface BjmesTokenDownloadLogoQuery<TData> extends BjmesTokenReactQuery<DownloadLogoResponse, TData> {}
export function useBjmesTokenDownloadLogoQuery<TData = DownloadLogoResponse>({
  client,
  options
}: BjmesTokenDownloadLogoQuery<TData>) {
  return useQuery<DownloadLogoResponse, Error, TData>(bjmesTokenQueryKeys.downloadLogo(client?.contractAddress), () => client ? client.downloadLogo() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface BjmesTokenMarketingInfoQuery<TData> extends BjmesTokenReactQuery<MarketingInfoResponse, TData> {}
export function useBjmesTokenMarketingInfoQuery<TData = MarketingInfoResponse>({
  client,
  options
}: BjmesTokenMarketingInfoQuery<TData>) {
  return useQuery<MarketingInfoResponse, Error, TData>(bjmesTokenQueryKeys.marketingInfo(client?.contractAddress), () => client ? client.marketingInfo() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface BjmesTokenAllAccountsQuery<TData> extends BjmesTokenReactQuery<AllAccountsResponse, TData> {
  args: {
    limit?: number;
    startAfter?: string;
  };
}
export function useBjmesTokenAllAccountsQuery<TData = AllAccountsResponse>({
  client,
  args,
  options
}: BjmesTokenAllAccountsQuery<TData>) {
  return useQuery<AllAccountsResponse, Error, TData>(bjmesTokenQueryKeys.allAccounts(client?.contractAddress, args), () => client ? client.allAccounts({
    limit: args.limit,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface BjmesTokenAllSpenderAllowancesQuery<TData> extends BjmesTokenReactQuery<AllSpenderAllowancesResponse, TData> {
  args: {
    limit?: number;
    spender: string;
    startAfter?: string;
  };
}
export function useBjmesTokenAllSpenderAllowancesQuery<TData = AllSpenderAllowancesResponse>({
  client,
  args,
  options
}: BjmesTokenAllSpenderAllowancesQuery<TData>) {
  return useQuery<AllSpenderAllowancesResponse, Error, TData>(bjmesTokenQueryKeys.allSpenderAllowances(client?.contractAddress, args), () => client ? client.allSpenderAllowances({
    limit: args.limit,
    spender: args.spender,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface BjmesTokenAllAllowancesQuery<TData> extends BjmesTokenReactQuery<AllAllowancesResponse, TData> {
  args: {
    limit?: number;
    owner: string;
    startAfter?: string;
  };
}
export function useBjmesTokenAllAllowancesQuery<TData = AllAllowancesResponse>({
  client,
  args,
  options
}: BjmesTokenAllAllowancesQuery<TData>) {
  return useQuery<AllAllowancesResponse, Error, TData>(bjmesTokenQueryKeys.allAllowances(client?.contractAddress, args), () => client ? client.allAllowances({
    limit: args.limit,
    owner: args.owner,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface BjmesTokenAllowanceQuery<TData> extends BjmesTokenReactQuery<AllowanceResponse, TData> {
  args: {
    owner: string;
    spender: string;
  };
}
export function useBjmesTokenAllowanceQuery<TData = AllowanceResponse>({
  client,
  args,
  options
}: BjmesTokenAllowanceQuery<TData>) {
  return useQuery<AllowanceResponse, Error, TData>(bjmesTokenQueryKeys.allowance(client?.contractAddress, args), () => client ? client.allowance({
    owner: args.owner,
    spender: args.spender
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface BjmesTokenMinterQuery<TData> extends BjmesTokenReactQuery<MinterResponse, TData> {}
export function useBjmesTokenMinterQuery<TData = MinterResponse>({
  client,
  options
}: BjmesTokenMinterQuery<TData>) {
  return useQuery<MinterResponse, Error, TData>(bjmesTokenQueryKeys.minter(client?.contractAddress), () => client ? client.minter() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface BjmesTokenTokenInfoQuery<TData> extends BjmesTokenReactQuery<TokenInfoResponse, TData> {}
export function useBjmesTokenTokenInfoQuery<TData = TokenInfoResponse>({
  client,
  options
}: BjmesTokenTokenInfoQuery<TData>) {
  return useQuery<TokenInfoResponse, Error, TData>(bjmesTokenQueryKeys.tokenInfo(client?.contractAddress), () => client ? client.tokenInfo() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface BjmesTokenTotalSupplyAtQuery<TData> extends BjmesTokenReactQuery<Uint128, TData> {
  args: {
    block: number;
  };
}
export function useBjmesTokenTotalSupplyAtQuery<TData = Uint128>({
  client,
  args,
  options
}: BjmesTokenTotalSupplyAtQuery<TData>) {
  return useQuery<Uint128, Error, TData>(bjmesTokenQueryKeys.totalSupplyAt(client?.contractAddress, args), () => client ? client.totalSupplyAt({
    block: args.block
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface BjmesTokenBalanceAtQuery<TData> extends BjmesTokenReactQuery<BalanceResponse, TData> {
  args: {
    address: string;
    block: number;
  };
}
export function useBjmesTokenBalanceAtQuery<TData = BalanceResponse>({
  client,
  args,
  options
}: BjmesTokenBalanceAtQuery<TData>) {
  return useQuery<BalanceResponse, Error, TData>(bjmesTokenQueryKeys.balanceAt(client?.contractAddress, args), () => client ? client.balanceAt({
    address: args.address,
    block: args.block
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface BjmesTokenBalanceQuery<TData> extends BjmesTokenReactQuery<BalanceResponse, TData> {
  args: {
    address: string;
  };
}
export function useBjmesTokenBalanceQuery<TData = BalanceResponse>({
  client,
  args,
  options
}: BjmesTokenBalanceQuery<TData>) {
  return useQuery<BalanceResponse, Error, TData>(bjmesTokenQueryKeys.balance(client?.contractAddress, args), () => client ? client.balance({
    address: args.address
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface BjmesTokenUploadLogoMutation {
  client: BjmesTokenClient;
  msg: Logo;
  args?: {
    coins?: Coins;
  };
}
export function useBjmesTokenUploadLogoMutation(options?: Omit<UseMutationOptions<WaitTxBroadcastResult, Error, BjmesTokenUploadLogoMutation>, "mutationFn">) {
  return useMutation<WaitTxBroadcastResult, Error, BjmesTokenUploadLogoMutation>(({
    client,
    msg,
    args: {
      coins
    } = {}
  }) => client.uploadLogo(coins), options);
}
export interface BjmesTokenUpdateMarketingMutation {
  client: BjmesTokenClient;
  msg: {
    description?: string;
    marketing?: string;
    project?: string;
  };
  args?: {
    coins?: Coins;
  };
}
export function useBjmesTokenUpdateMarketingMutation(options?: Omit<UseMutationOptions<WaitTxBroadcastResult, Error, BjmesTokenUpdateMarketingMutation>, "mutationFn">) {
  return useMutation<WaitTxBroadcastResult, Error, BjmesTokenUpdateMarketingMutation>(({
    client,
    msg,
    args: {
      coins
    } = {}
  }) => client.updateMarketing(msg, coins), options);
}
export interface BjmesTokenUpdateMinterMutation {
  client: BjmesTokenClient;
  msg: {
    newMinter?: string;
  };
  args?: {
    coins?: Coins;
  };
}
export function useBjmesTokenUpdateMinterMutation(options?: Omit<UseMutationOptions<WaitTxBroadcastResult, Error, BjmesTokenUpdateMinterMutation>, "mutationFn">) {
  return useMutation<WaitTxBroadcastResult, Error, BjmesTokenUpdateMinterMutation>(({
    client,
    msg,
    args: {
      coins
    } = {}
  }) => client.updateMinter(msg, coins), options);
}
export interface BjmesTokenMintMutation {
  client: BjmesTokenClient;
  msg: {
    amount: Uint128;
    recipient: string;
  };
  args?: {
    coins?: Coins;
  };
}
export function useBjmesTokenMintMutation(options?: Omit<UseMutationOptions<WaitTxBroadcastResult, Error, BjmesTokenMintMutation>, "mutationFn">) {
  return useMutation<WaitTxBroadcastResult, Error, BjmesTokenMintMutation>(({
    client,
    msg,
    args: {
      coins
    } = {}
  }) => client.mint(msg, coins), options);
}
export interface BjmesTokenBurnFromMutation {
  client: BjmesTokenClient;
  msg: {
    amount: Uint128;
    owner: string;
  };
  args?: {
    coins?: Coins;
  };
}
export function useBjmesTokenBurnFromMutation(options?: Omit<UseMutationOptions<WaitTxBroadcastResult, Error, BjmesTokenBurnFromMutation>, "mutationFn">) {
  return useMutation<WaitTxBroadcastResult, Error, BjmesTokenBurnFromMutation>(({
    client,
    msg,
    args: {
      coins
    } = {}
  }) => client.burnFrom(msg, coins), options);
}
export interface BjmesTokenSendFromMutation {
  client: BjmesTokenClient;
  msg: {
    amount: Uint128;
    contract: string;
    msg: Binary;
    owner: string;
  };
  args?: {
    coins?: Coins;
  };
}
export function useBjmesTokenSendFromMutation(options?: Omit<UseMutationOptions<WaitTxBroadcastResult, Error, BjmesTokenSendFromMutation>, "mutationFn">) {
  return useMutation<WaitTxBroadcastResult, Error, BjmesTokenSendFromMutation>(({
    client,
    msg,
    args: {
      coins
    } = {}
  }) => client.sendFrom(msg, coins), options);
}
export interface BjmesTokenTransferFromMutation {
  client: BjmesTokenClient;
  msg: {
    amount: Uint128;
    owner: string;
    recipient: string;
  };
  args?: {
    coins?: Coins;
  };
}
export function useBjmesTokenTransferFromMutation(options?: Omit<UseMutationOptions<WaitTxBroadcastResult, Error, BjmesTokenTransferFromMutation>, "mutationFn">) {
  return useMutation<WaitTxBroadcastResult, Error, BjmesTokenTransferFromMutation>(({
    client,
    msg,
    args: {
      coins
    } = {}
  }) => client.transferFrom(msg, coins), options);
}
export interface BjmesTokenDecreaseAllowanceMutation {
  client: BjmesTokenClient;
  msg: {
    amount: Uint128;
    expires?: Expiration;
    spender: string;
  };
  args?: {
    coins?: Coins;
  };
}
export function useBjmesTokenDecreaseAllowanceMutation(options?: Omit<UseMutationOptions<WaitTxBroadcastResult, Error, BjmesTokenDecreaseAllowanceMutation>, "mutationFn">) {
  return useMutation<WaitTxBroadcastResult, Error, BjmesTokenDecreaseAllowanceMutation>(({
    client,
    msg,
    args: {
      coins
    } = {}
  }) => client.decreaseAllowance(msg, coins), options);
}
export interface BjmesTokenIncreaseAllowanceMutation {
  client: BjmesTokenClient;
  msg: {
    amount: Uint128;
    expires?: Expiration;
    spender: string;
  };
  args?: {
    coins?: Coins;
  };
}
export function useBjmesTokenIncreaseAllowanceMutation(options?: Omit<UseMutationOptions<WaitTxBroadcastResult, Error, BjmesTokenIncreaseAllowanceMutation>, "mutationFn">) {
  return useMutation<WaitTxBroadcastResult, Error, BjmesTokenIncreaseAllowanceMutation>(({
    client,
    msg,
    args: {
      coins
    } = {}
  }) => client.increaseAllowance(msg, coins), options);
}
export interface BjmesTokenSendMutation {
  client: BjmesTokenClient;
  msg: {
    amount: Uint128;
    contract: string;
    msg: Binary;
  };
  args?: {
    coins?: Coins;
  };
}
export function useBjmesTokenSendMutation(options?: Omit<UseMutationOptions<WaitTxBroadcastResult, Error, BjmesTokenSendMutation>, "mutationFn">) {
  return useMutation<WaitTxBroadcastResult, Error, BjmesTokenSendMutation>(({
    client,
    msg,
    args: {
      coins
    } = {}
  }) => client.send(msg, coins), options);
}
export interface BjmesTokenBurnMutation {
  client: BjmesTokenClient;
  msg: {
    amount: Uint128;
  };
  args?: {
    coins?: Coins;
  };
}
export function useBjmesTokenBurnMutation(options?: Omit<UseMutationOptions<WaitTxBroadcastResult, Error, BjmesTokenBurnMutation>, "mutationFn">) {
  return useMutation<WaitTxBroadcastResult, Error, BjmesTokenBurnMutation>(({
    client,
    msg,
    args: {
      coins
    } = {}
  }) => client.burn(msg, coins), options);
}
export interface BjmesTokenTransferMutation {
  client: BjmesTokenClient;
  msg: {
    amount: Uint128;
    recipient: string;
  };
  args?: {
    coins?: Coins;
  };
}
export function useBjmesTokenTransferMutation(options?: Omit<UseMutationOptions<WaitTxBroadcastResult, Error, BjmesTokenTransferMutation>, "mutationFn">) {
  return useMutation<WaitTxBroadcastResult, Error, BjmesTokenTransferMutation>(({
    client,
    msg,
    args: {
      coins
    } = {}
  }) => client.transfer(msg, coins), options);
}